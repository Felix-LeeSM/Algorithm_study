use std::collections::VecDeque;

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let mut initial: Vec<_> = initial.into_iter().map(|num| num as usize).collect();
        initial.sort();
        let initial = initial;

        let n = graph.len();
        let mut link_graph = vec![vec![]; n];

        for r in 0..n {
            for c in 0..n {
                if graph[r][c] == 1 {
                    link_graph[r].push(c);
                    link_graph[c].push(r);
                }
            }
        }

        let mut visit_counts = vec![0; n];
        let mut sources = vec![usize::MAX; n];
        let mut queue = VecDeque::new();

        for &node in initial.iter() {
            visit_counts[node] += 1;
            sources[node] = node;

            queue.push_back((node, node));
        }

        while let Some((node, source)) = queue.pop_front() {
            for &next_node in link_graph[node].iter() {
                if visit_counts[next_node] == 0
                    || (visit_counts[next_node] == 1 && sources[next_node] != source)
                {
                    visit_counts[next_node] += 1;
                    sources[next_node] = source;

                    queue.push_back((next_node, source));
                }
            }
        }

        let mut single_deps = vec![0; n];
        for node in 0..n {
            if visit_counts[node] == 1 {
                let dep = sources[node];
                single_deps[dep] += 1;
            }
        }

        let (answer, _) = initial
            .into_iter()
            .map(|node| (node as usize, single_deps[node]))
            .reduce(|(prev, prev_reduced), (curr, curr_reduced)| {
                if prev_reduced < curr_reduced {
                    (curr, curr_reduced)
                } else {
                    (prev, prev_reduced)
                }
            })
            .unwrap();

        answer as i32
    }
}

fn main() {
    assert_eq!(
      0,
      Solution::min_malware_spread(vec![vec![1,1,0],vec![1,1,0],vec![0,0,1]], vec![0, 1]),
      "Solution::min_malware_spread(vec![vec![1,1,0],vec![1,1,0],vec![0,0,1]], vec![0, 1]) expects 0, got {}",
      Solution::min_malware_spread(vec![vec![1,1,0],vec![1,1,0],vec![0,0,1]], vec![0, 1])
  );

    assert_eq!(
      0,
      Solution::min_malware_spread(vec![vec![1,0,0],vec![0,1,0],vec![0,0,1]], vec![0, 2]),
      "Solution::min_malware_spread(vec![vec![1,0,0],vec![0,1,0],vec![0,0,1]], vec![0, 2]) expects 0, got {}",
      Solution::min_malware_spread(vec![vec![1,0,0],vec![0,1,0],vec![0,0,1]], vec![0, 2])
  );

    assert_eq!(
      1,
      Solution::min_malware_spread(vec![vec![1,1,1],vec![1,1,1],vec![1,1,1]], vec![1, 2]),
      "Solution::min_malware_spread(vec![vec![1,1,1],vec![1,1,1],vec![1,1,1]], vec![1, 2]) expects 1, got {}",
      Solution::min_malware_spread(vec![vec![1,1,1],vec![1,1,1],vec![1,1,1]], vec![1, 2])
  );

    assert_eq!(
      3,
      Solution::min_malware_spread(vec![vec![1,0,0,0],vec![0,1,0,0],vec![0,0,1,1],vec![0,0,1,1]], vec![1, 3]),
      "Solution::min_malware_spread(vec![vec![1,0,0,0],vec![0,1,0,0],vec![0,0,1,1],vec![0,0,1,1]], vec![1, 3]) expects 3, got {}",
      Solution::min_malware_spread(vec![vec![1,0,0,0],vec![0,1,0,0],vec![0,0,1,1],vec![0,0,1,1]], vec![1, 3])
  );

    assert_eq!(
      0,
      Solution::min_malware_spread(vec![vec![1,0,0,0,0,0],vec![0,1,0,0,0,0],vec![0,0,1,0,0,0],vec![0,0,0,1,1,0],vec![0,0,0,1,1,0],vec![0,0,0,0,0,1]], vec![5,0]),
      "Solution::min_malware_spread(vec![vec![1,0,0,0,0,0],vec![0,1,0,0,0,0],vec![0,0,1,0,0,0],vec![0,0,0,1,1,0],vec![0,0,0,1,1,0],vec![0,0,0,0,0,1]], vec![5,0]) expects 0, got {}",
      Solution::min_malware_spread(vec![vec![1,0,0,0,0,0],vec![0,1,0,0,0,0],vec![0,0,1,0,0,0],vec![0,0,0,1,1,0],vec![0,0,0,1,1,0],vec![0,0,0,0,0,1]], vec![5,0])
  );
}
