
'''
징검다리 건너기
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다.
"라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.
"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.
"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 
최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

[제한사항]
징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
stones 배열의 크기는 1 이상 200,000 이하입니다.
stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
k는 1 이상 stones의 길이 이하인 자연수입니다.
[입출력 예]
stones	k	result
[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]	3	3
입출력 예에 대한 설명
입출력 예 #1

첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.

첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 
하지만 k = 3 이므로 건너뛸 수 없습니다.

따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.
'''

# s의 원소의 최대값은 200,000,000이하이다.
# 따라서, 이분탐색을 해야한다.


def solution(s, k):
    def check(n):
        temp = 0
        for idx in range(len(s)):
            if s[idx] > n:
                temp = 0
            else:
                temp += 1
            if temp >= k:
                return False
        return True
    left = 0
    right = 200000000
    while left < right:
        mid = (left+right)//2
        if check(mid):
            left = mid+1
        else:
            right = mid
    return left


print(solution([2, 4, 5, 3, 2, 1, 4, 2, 5, 1], 3))

'''
정확성  테스트
테스트 1 〉	    통과 (0.02ms, 10.3MB)
테스트 2 〉	    통과 (0.02ms, 10.2MB)
테스트 3 〉	    통과 (0.02ms, 10.3MB)
테스트 4 〉	    통과 (0.03ms, 10MB)
테스트 5 〉	    통과 (0.06ms, 10.3MB)
테스트 6 〉	    통과 (0.29ms, 10.2MB)
테스트 7 〉	    통과 (0.52ms, 10.2MB)
테스트 8 〉	    통과 (0.62ms, 10.2MB)
테스트 9 〉	    통과 (0.94ms, 10.2MB)
테스트 10 〉	통과 (0.03ms, 10.1MB)
테스트 11 〉	통과 (0.02ms, 10.3MB)
테스트 12 〉	통과 (0.04ms, 10.1MB)
테스트 13 〉	통과 (0.08ms, 10.2MB)
테스트 14 〉	통과 (0.18ms, 10.1MB)
테스트 15 〉	통과 (0.53ms, 10.2MB)
테스트 16 〉	통과 (0.50ms, 10.2MB)
테스트 17 〉	통과 (0.54ms, 10.2MB)
테스트 18 〉	통과 (0.02ms, 10MB)
테스트 19 〉	통과 (0.04ms, 10.3MB)
테스트 20 〉	통과 (0.06ms, 10.2MB)
테스트 21 〉	통과 (0.17ms, 10.3MB)
테스트 22 〉	통과 (0.73ms, 10.2MB)
테스트 23 〉	통과 (0.61ms, 10.2MB)
테스트 24 〉	통과 (0.68ms, 10.2MB)
테스트 25 〉	통과 (0.02ms, 10.2MB)
효율성  테스트
테스트 1 〉	    통과 (255.03ms, 18.6MB)
테스트 2 〉	    통과 (289.85ms, 18.6MB)
테스트 3 〉	    통과 (352.05ms, 18.5MB)
테스트 4 〉	    통과 (238.02ms, 18.5MB)
테스트 5 〉	    통과 (273.39ms, 18.5MB)
테스트 6 〉	    통과 (264.25ms, 18.5MB)
테스트 7 〉	    통과 (386.43ms, 18.6MB)
테스트 8 〉	    통과 (397.93ms, 18.6MB)
테스트 9 〉	    통과 (440.51ms, 18.6MB)
테스트 10 〉	통과 (426.08ms, 18.6MB)
테스트 11 〉	통과 (343.03ms, 18.5MB)
테스트 12 〉	통과 (389.19ms, 18.5MB)
테스트 13 〉	통과 (289.60ms, 18.5MB)
테스트 14 〉	통과 (253.63ms, 18.5MB)
'''
'''
#include <string>
#include <vector>

using namespace std;

bool check(int piv, int m, vector<int> s) {
    int temp = 0;
    for (int idx = 0; idx < s.size(); idx++) {
        if (s[idx] > piv) {
            temp = 0;
        } else {
            temp++;
        }
        if (temp >= m) {
            return false;
        }
    }
    return true;
}

int solution(vector<int> stones, int k) {
    int left = 0;
    int right = 200000000;
    while (left < right) {
        int mid = (left+right)/2;
        if (check(mid, k, stones)) {
            left = mid+1;
        } else {
            right = mid;
        }
    }
    return left;
}

채점을 시작합니다.
정확성  테스트
테스트 1 〉	    통과 (0.01ms, 4.15MB)
테스트 2 〉	    통과 (0.01ms, 3.66MB)
테스트 3 〉	    통과 (0.01ms, 4.16MB)
테스트 4 〉	    통과 (0.01ms, 4.16MB)
테스트 5 〉	    통과 (0.01ms, 3.59MB)
테스트 6 〉	    통과 (0.01ms, 4.18MB)
테스트 7 〉	    통과 (0.02ms, 4.17MB)
테스트 8 〉	    통과 (0.02ms, 4.11MB)
테스트 9 〉	    통과 (0.02ms, 4.09MB)
테스트 10 〉	통과 (0.01ms, 3.65MB)
테스트 11 〉	통과 (0.01ms, 4.17MB)
테스트 12 〉	통과 (0.01ms, 4.18MB)
테스트 13 〉	통과 (0.01ms, 4.11MB)
테스트 14 〉	통과 (0.02ms, 4.18MB)
테스트 15 〉	통과 (0.03ms, 4.16MB)
테스트 16 〉	통과 (0.02ms, 4.16MB)
테스트 17 〉	통과 (0.02ms, 4.17MB)
테스트 18 〉	통과 (0.01ms, 3.58MB)
테스트 19 〉	통과 (0.01ms, 4.18MB)
테스트 20 〉	통과 (0.01ms, 3.59MB)
테스트 21 〉	통과 (0.02ms, 4.24MB)
테스트 22 〉	통과 (0.02ms, 4.1MB)
테스트 23 〉	통과 (0.02ms, 4.14MB)
테스트 24 〉	통과 (0.02ms, 4.16MB)
테스트 25 〉	통과 (0.01ms, 4.11MB)
효율성  테스트
테스트 1 〉	    통과 (4.22ms, 11.1MB)
테스트 2 〉	    통과 (4.40ms, 10.8MB)
테스트 3 〉	    통과 (5.00ms, 10.9MB)
테스트 4 〉	    통과 (4.60ms, 11.2MB)
테스트 5 〉	    통과 (4.80ms, 11.2MB)
테스트 6 〉	    통과 (4.65ms, 11.1MB)
테스트 7 〉	    통과 (5.12ms, 11.2MB)
테스트 8 〉	    통과 (5.19ms, 11.2MB)
테스트 9 〉	    통과 (5.31ms, 10.9MB)
테스트 10 〉	통과 (5.47ms, 10.9MB)
테스트 11 〉	통과 (5.14ms, 10.9MB)
테스트 12 〉	통과 (4.83ms, 10.8MB)
테스트 13 〉	통과 (4.75ms, 11.2MB)
테스트 14 〉	통과 (4.41ms, 11.1MB)
채점 결과
정확성: 64.1
효율성: 35.9
합계: 100.0 / 100.0

'''
